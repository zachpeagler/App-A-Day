---
title: "distribution tests"
author: "Zach Peagler"
date: "10/12/2024"
output: html_document
---

## Load Packages
```{r packages, include=FALSE}
require(dplyr); require(MASS); require(fitdistrplus); require(scico)
```

## Graphical Setup
```{r gsetup}
a_palette <- "lipari"
```

## Test Data
```{r test_data}

c02dat <- read.csv("C:/Github/App-A-Day/02_distribution_fitter/SupplyChainGHGEmissionFactors_v1.3.0_NAICS_CO2e_USD2022.csv")
ghgdat <- read.csv("C:/Github/App-A-Day/02_distribution_fitter/SupplyChainGHGEmissionFactors_v1.3.0_NAICS_byGHG_USD2022.csv")

x <- c02dat$Supply.Chain.Emission.Factors.with.Margins
seq_length <- 100

```

## Continuous PDF
### Description
This is used to test the distribution of non-negative continuous variables. It returns a dataframe (table) with the x value and then the predicted distribution based on that.
### Usage
> cont_pdf(x, seq_length, distributions, ...)

### Arguments
x <- the variable that is being fitted against distributions. must be continuous and non-negative.
seq_length <- the length of the sequence used to generate distributions. results in the number of rows in the final output.
distributions <- a list of distributions to test against. options include "normal", "lognormal", "Gamma", "exponential", "beta", "cauchy", "t", "weibull", "logistic", and "geometric". calling "all" will return all possible distributions.

```{r distributions}

# (-inf:inf)

# (0:inf)
cont_distributions <- function() {
  return(c("normal", "lognormal", "gamma", "exponential", "cauchy", "t", "weibull", "logistic"))
}

# (0-1)
## beta, 

#  if ("beta" %in% distributions) {
#    x_beta <- fitdist(x, "beta")
#  }

# geometric / number of fails in a sequence of Bernoulli trials before success occurs

#  if ("geometric" %in% distributions) {
#    x_geom <- fitdistr(x, "geometric")
#  }

```

### Details

Uses sequence length via seq() on the min and max of x over seq_length + 1. 

Then computes the kernel density of x with density().

Create a new dataframe out of the x sequence and computed kernel density.

Check distributions against each supported distribution. If requested (and capable of doing so; continuous non-negative numbers required.) it fits the distribution of x against the requested distribution and adds it to the returned dataframe.
```{r cont_pdf}

cont_pdf <- function(x, seq_length, distributions){
  # get a sequence from the minimum to maximum of x with length
  #equal to seq_length + 1
  x_seq <- seq(min(x), max(x), length.out = seq_length+1)
  # create real density for x
  x_pdf <- density(x, n=seq_length+1)
  # initialize df of x and the real density
  pdf_df <- as.data.frame(x_seq) %>%
    mutate(dens = x_pdf$y)
  if ("all" %in% distributions) {
    distributions <- c("normal", "lognormal", "gamma", "exponential",
                       "cauchy", "t", "weibull", "logistic")
  }
  
  if ("normal" %in% distributions) {
    x_n <- fitdistr(x, "normal")
    x_pdf_n <- dnorm(x_seq, mean=x_n$estimate[1],
                   sd = x_n$estimate[2])
    pdf_df <- pdf_df %>% mutate(pdf_normal = x_pdf_n)
  }
  if ("lognormal" %in% distributions) {
      x_ln <- fitdistr(x, "lognormal")
      x_pdf_ln <- dlnorm(x_seq, meanlog=x_ln$estimate[1],
                   sdlog = x_ln$estimate[2])
      pdf_df <- pdf_df %>% mutate(pdf_lognormal = x_pdf_ln)
  }
  if ("gamma" %in% distributions) {
    x_g <- fitdistr(x, "gamma")
    x_pdf_g <- dgamma(x_seq, shape=x_g$estimate[1],
                    rate=x_g$estimate[2])
    pdf_df <- pdf_df %>% mutate(pdf_gamma = x_pdf_g)
  }
  if ("exponential" %in% distributions) {
    x_exp <- fitdistr(x, "exponential")
    x_pdf_exp <- dexp(x_seq, rate = x_exp$estimate)
    pdf_df <- pdf_df %>% mutate(pdf_exponential = x_pdf_exp)
  }
  if ("cauchy" %in% distributions) {
    x_cau <- fitdistr(x, "cauchy")
    x_pdf_cau <- dcauchy(x_seq, location=x_cau$estimate[1],
                         scale = x_cau$estimate[2])
    pdf_df <- pdf_df %>% mutate(pdf_cauchy = x_pdf_cau)
  }
  if ("t" %in% distributions) {
    x_t <- fitdistr(x, "t")
    x_pdf_t <- dt(x_seq, df = x_t$estimate[3])
    pdf_df <- pdf_df %>% mutate(pdf_t = x_pdf_t)
  }
  if ("weibull" %in% distributions) {
    x_wei <- fitdistr(x, "weibull")
    x_pdf_wei <- dweibull(x_seq, shape = x_wei$estimate[1],
                    scale = x_wei$estimate[2])
    pdf_df <- pdf_df %>% mutate(pdf_weibull = x_pdf_wei)
  }
  if ("logistic" %in% distributions) {
    x_logis <- fitdistr(x, "logistic")
    x_pdf_logis <- dlogis(x_seq, x_logis$estimate[1],
                          x_logis$estimate[2])
    pdf_df <- pdf_df %>% mutate(pdf_logistic = x_pdf_logis)
  }

  return(pdf_df)
}

c02_nomargin_pdfs <- cont_pdf(c02dat$Supply.Chain.Emission.Factors.without.Margins,
                              1000, "all")

```

### A function to return a ggplot showing the probability distribution function of a variable.
```{r ggpdf}

ggplot(c02_nomargin_pdfs) +
    geom_point(aes(x=x_seq, y=dens, color = "Real Density"), size=3, shape =16)+
    geom_point(aes(x=x_seq, y=pdf_normal, color="Normal"), shape=17)+
    geom_point(aes(x=x_seq, y=pdf_lognormal, color="Lognormal"), shape=18)+
    geom_point(aes(x=x_seq, y=pdf_gamma, color="Gamma"), shape=0)+
    geom_point(aes(x=x_seq, y=pdf_exponential, color="Exponential"), shape=1)+
    geom_point(aes(x=x_seq, y=pdf_cauchy, color="Cauchy"), shape=2)+
    geom_point(aes(x=x_seq, y=pdf_t, color="t"), shape=5)+
    geom_point(aes(x=x_seq, y=pdf_weibull, color="Weibull"), shape=6)+
    geom_point(aes(x=x_seq, y=pdf_logistic, color="Logistic"), shape=7)+
    theme_bw()+
    xlim(0,1)+
    scale_color_scico_d(begin=0, end=0.8, palette = a_palette)+
    scale_shape_discrete()+
    ylab("PDF")+
    xlab("x")+
    theme(
      text = element_text(size=24, family="mont"),
      legend.position="inside",
      legend.position.inside = c(.85,.6),
      axis.title = element_text(size=24, family = "mont", face= "bold"),
    )

```
